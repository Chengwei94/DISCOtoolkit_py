#' Geneset enrichment analysis using DISCO data
#'
#' @param input A one or two columns data.frame. The first column is gene and the second column is log2FC (optional)
#' @param reference Reference geneset If not specified, reference geneset will be downloaded from the DISCO database.
#' @param ref.path Specify the file path to save the downloaded reference geneset data.
#' @param ncores Number of core used for CELLiD
#' @export
CELLiDEnrichment <- function(input, reference = NULL, ref.path = NULL, ncores = 10){
  # check input data
  if (!(is.data.frame(input))) {
    stop("The input must be a data frame")
  }
  if (ncol(input) > 2) {
    stop("The input must be one or two columns")
  }
  if (ncol(input) == 2) {
    colnames(input) = c("gene", "fc")
  }else {
    colnames(input) = c("gene")
  }


  if (is.null(reference)) {
    #TODO reference url
    op = options(timeout=600)
    on.exit(options(op), add = TRUE)
    if (is.null(ref.path)) {
      dir.create("DISCOtmp")
      ref.path = "DISCOtmp"
    }
    download.file("http://www.immunesinglecell.org/toolkitapi/getGeneSet",
                  paste0(ref.path, "/ref_geneset.rds"), method = "curl")
    reference = readRDS(paste0(ref.path, "/ref_geneset.rds"))
  }
  reference$name = paste0(reference$name, " in ", reference$atlas)

  if(ncol(input) == 2) {
    input$fc = 2^input$fc
    rownames(input) = input$gene
    input = input[intersect(reference$gene, input$gene),]

    res = pbmclapply(
      unique(reference$name), function(i) {
        atlas = str_match(i, " in (.*?$)")[,2]
        reference.filter = reference[which(reference$name == i),]
        reference.full = reference[which(reference$atlas == atlas),]
        rownames(reference.filter) = reference.filter$gene
        input.filter = input[intersect(reference.full$gene, input$gene),]

        if (length(input.filter) == 0) {
          return(NULL)
        }

        a = sum(reference.filter[intersect(reference.filter$gene, input.filter$gene),1] * input.filter[intersect(reference.filter$gene, input.filter$gene),2]) + 1
        b = sum(input.filter[setdiff(input.filter$gene, reference.filter$gene),2]) + 1
        c = sum(reference.filter[setdiff(reference.filter$gene,input.filter$gene),1]) + 1
        d = length(unique(reference.full$gene)) - length(unique(c(reference.filter$gene,input.filter$gene)))
        r = fisher.test(matrix(c(a,b,c,d), nrow = 2))
        if (r$p.value < 0.01) {
          return(c(r$p.value, as.numeric(r$estimate), i,
                   paste0(intersect(reference.filter$gene, input.filter$gene), collapse  = ","),
                   length(unique(reference.full$gene)), length(intersect(reference.filter$gene,input.filter$gene)), length(reference.filter$gene)))
        } else {
          return(NULL)
        }
      }, mc.cores = ncores
    )
  }else {
    input = toupper(input$gene)
    input = intersect(reference$gene, input)

    res = pbmclapply(
      unique(reference$name), function(i) {
        atlas = str_match(i, " in (.*?$)")[,2]
        reference.filter = reference[which(reference$name == i),]
        reference.full = reference[which(reference$atlas == atlas),]

        input.filter = intersect(reference.full$gene, input)

        if (length(input.filter) == 0) {
          return(NULL)
        }

        a = length(intersect(reference.filter$gene, input.filter)) + 1
        b = length(setdiff(input.filter, reference.filter$gene)) + 1
        c = length(setdiff(reference.filter$gene, input.filter)) + 1
        d = length(unique(reference.full$gene)) - a - b -c
        r = fisher.test(matrix(c(a,b,c,d), nrow = 2))
        if (r$p.value < 0.01) {
          return(c(r$p.value, as.numeric(r$estimate), i,
                   paste0(intersect(reference.filter$gene, input.filter), collapse  = ","),
                   length(unique(reference.full$gene)), length(intersect(reference.filter$gene,input.filter)), length(reference.filter$gene)))
        } else {
          return(NULL)
        }
      }, mc.cores = ncores
    )
  }

  res = do.call(rbind, res)
  res = data.frame(res)
  res$X1 = as.numeric(res$X1)
  res$X2 = as.numeric(res$X2)
  res = res[order(res$X1,-res$X2),]
  colnames(res) = c("pval", "or", "name", "gene", "background", "overlap", "geneset")
  res$or = round(as.numeric(res$or), 2)
  res$pval = signif(as.numeric(res$pval), digits=2)
  res = res[1:min(50, nrow(res)),,drop=F]
  return(res)
}
